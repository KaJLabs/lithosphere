#!/usr/bin/env bash
# =============================================================================
# deploy-indexer-ec2.sh
# Deploy the Lithosphere Explorer & Indexer stack on the production Indexer-EC2
# node (10.0.10.65) via Bastion SSH to resolve the 522 Timeout error.
#
# Usage:
#   chmod +x deploy-indexer-ec2.sh
#   ./deploy-indexer-ec2.sh \
#     --bastion <bastion-public-ip-or-hostname> \
#     --key     <path-to-ssh-private-key>
#
# Optional flags:
#   --bastion-user  <user>   SSH user for bastion  (default: ec2-user)
#   --target-user   <user>   SSH user for indexer  (default: ec2-user)
#   --sg-id         <id>     AWS Security Group ID to open port 3000
#                            (e.g. sg-0abc123456def789a)
#   --dry-run                Print commands without executing remote steps
#
# Prerequisites (local machine):
#   - ssh-agent loaded with the relevant key, OR --key flag provided
#   - AWS CLI configured with permissions to modify security groups (optional)
#   - The bastion and target share the same SSH key pair
# =============================================================================

set -euo pipefail

# ── Colour helpers ────────────────────────────────────────────────────────────
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'
CYAN='\033[0;36m'; BOLD='\033[1m'; RESET='\033[0m'

info()    { echo -e "${CYAN}[INFO]${RESET}  $*"; }
success() { echo -e "${GREEN}[OK]${RESET}    $*"; }
warn()    { echo -e "${YELLOW}[WARN]${RESET}  $*"; }
error()   { echo -e "${RED}[ERROR]${RESET} $*" >&2; exit 1; }
step()    { echo -e "\n${BOLD}══ $* ${RESET}"; }

# ── Defaults ──────────────────────────────────────────────────────────────────
BASTION_HOST=""
BASTION_USER="ec2-user"
TARGET_IP="10.0.10.65"
TARGET_USER="ec2-user"
SSH_KEY=""
SG_ID=""
DRY_RUN=false

DEPLOY_DIR="/opt/lithoscan"
ENV_DIR="${DEPLOY_DIR}/monitoring/explorer"
ENV_FILE="${ENV_DIR}/.env"

# Production environment values — use Sentry nodes, NEVER the Validator
CHAIN_ID="lithosphere_777777-1"
CHAIN_NAME="Lithosphere"
RPC_URL="https://rpc.litho.ai"
EVM_RPC_URL="http://litho-mainnet-rpc-nlb-90cbce98dabd2453.elb.us-east-1.amazonaws.com:8545"
GRPC_URL="54.163.248.63:9090"
RPC_ENDPOINTS="https://rpc.litho.ai,http://52.41.98.79:26657"
GRPC_ENDPOINTS="54.163.248.63:9090,52.41.98.79:9090"
NEXT_PUBLIC_SITE_URL="https://makalu.litho.ai"
NEXT_PUBLIC_API_URL="https://api.litho.ai"
NEXT_PUBLIC_RPC_URL="https://rpc.litho.ai"

# ── Argument parsing ──────────────────────────────────────────────────────────
while [[ $# -gt 0 ]]; do
  case "$1" in
    --bastion)       BASTION_HOST="$2";  shift 2 ;;
    --bastion-user)  BASTION_USER="$2";  shift 2 ;;
    --target-user)   TARGET_USER="$2";   shift 2 ;;
    --key)           SSH_KEY="$2";       shift 2 ;;
    --sg-id)         SG_ID="$2";         shift 2 ;;
    --dry-run)       DRY_RUN=true;       shift   ;;
    *) error "Unknown argument: $1" ;;
  esac
done

[[ -z "$BASTION_HOST" ]] && error "--bastion <host> is required."

# ── SSH helper ────────────────────────────────────────────────────────────────
SSH_OPTS="-o StrictHostKeyChecking=no -o BatchMode=yes -o ConnectTimeout=15"
[[ -n "$SSH_KEY" ]] && SSH_OPTS="${SSH_OPTS} -i ${SSH_KEY}"

# ProxyJump tunnels through the Bastion in a single hop
PROXY_OPTS="${SSH_OPTS} -o ProxyJump=${BASTION_USER}@${BASTION_HOST}"

remote() {
  # remote <description> <bash commands>
  local desc="$1"; shift
  info "Remote: ${desc}"
  if $DRY_RUN; then
    echo -e "  ${YELLOW}[DRY-RUN]${RESET} Would run:\n  $*"
    return 0
  fi
  # shellcheck disable=SC2086
  ssh ${PROXY_OPTS} "${TARGET_USER}@${TARGET_IP}" "bash -s" <<< "$@"
}

# =============================================================================
# STEP 1 — Verify SSH connectivity through Bastion
# =============================================================================
step "Step 1 — Verify SSH connectivity (Bastion → Indexer-EC2)"

info "Testing jump: localhost → ${BASTION_USER}@${BASTION_HOST} → ${TARGET_USER}@${TARGET_IP}"
if ! $DRY_RUN; then
  # shellcheck disable=SC2086
  if ! ssh ${PROXY_OPTS} "${TARGET_USER}@${TARGET_IP}" "echo 'SSH OK'" 2>/dev/null; then
    error "Cannot reach ${TARGET_IP} via bastion ${BASTION_HOST}. Check your key, security groups, and bastion config."
  fi
fi
success "SSH connectivity confirmed."

# =============================================================================
# STEP 2 — Ensure the deploy directory and .env file are in place
# =============================================================================
step "Step 2 — Write production .env to ${ENV_FILE}"

remote "Create env directory and write .env" "
set -euo pipefail
sudo mkdir -p '${ENV_DIR}'
sudo tee '${ENV_FILE}' > /dev/null <<'ENVEOF'
# ── Lithosphere Explorer — Production Environment ──────────────────────────
# Generated by deploy-indexer-ec2.sh on \$(date -u '+%Y-%m-%dT%H:%M:%SZ')
# DO NOT edit this file manually; re-run the deploy script to update.

# Chain
CHAIN_ID=${CHAIN_ID}
CHAIN_NAME=${CHAIN_NAME}

# Endpoints — Public domains (TLS via Nginx on Sentry 1)
RPC_URL=${RPC_URL}
EVM_RPC_URL=${EVM_RPC_URL}
GRPC_URL=${GRPC_URL}
RPC_ENDPOINTS=${RPC_ENDPOINTS}
GRPC_ENDPOINTS=${GRPC_ENDPOINTS}

# Indexer
START_BLOCK=1
BATCH_SIZE=100
LOG_LEVEL=info

# API
NODE_ENV=production
CORS_ORIGINS=https://makalu.litho.ai,https://status.litho.ai

# Frontend
NEXT_PUBLIC_SITE_URL=${NEXT_PUBLIC_SITE_URL}
NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL}
NEXT_PUBLIC_RPC_URL=${NEXT_PUBLIC_RPC_URL}
NEXT_PUBLIC_CHAIN_ID=${CHAIN_ID}
NEXT_PUBLIC_CHAIN_NAME=${CHAIN_NAME}

# Network status
CHECK_INTERVAL=5000

# Database (set passwords on the host, not here)
POSTGRES_DB=lithoscan
POSTGRES_USER=litho
ENVEOF
sudo chmod 640 '${ENV_FILE}'
echo '.env written:'
cat '${ENV_FILE}'
"

success ".env written to ${ENV_FILE}."

# =============================================================================
# STEP 3 — Verify the deploy directory exists and docker-compose file is present
# =============================================================================
step "Step 3 — Verify deploy directory at ${DEPLOY_DIR}"

remote "Check for docker-compose file" "
set -euo pipefail
if [[ ! -d '${DEPLOY_DIR}' ]]; then
  echo 'ERROR: ${DEPLOY_DIR} does not exist on this node.' >&2
  exit 1
fi
COMPOSE_FILE=\$(find '${DEPLOY_DIR}' -maxdepth 2 \
  \\( -name 'docker-compose.yml' -o -name 'docker-compose.yaml' \
     -o -name 'compose.yml'      -o -name 'compose.yaml' \\) \
  -print -quit)
if [[ -z \"\$COMPOSE_FILE\" ]]; then
  echo 'ERROR: No docker-compose file found under ${DEPLOY_DIR}' >&2
  ls -la '${DEPLOY_DIR}'
  exit 1
fi
echo \"Found compose file: \$COMPOSE_FILE\"
echo \"Directory contents:\"
ls -la '${DEPLOY_DIR}'
"

success "Deploy directory verified."

# =============================================================================
# STEP 4 — Open port 3000 on the Indexer-EC2 Security Group (optional)
# =============================================================================
step "Step 4 — Security Group: ensure port 3000 is open"

if [[ -n "$SG_ID" ]]; then
  info "Checking Security Group ${SG_ID} for TCP/3000 ingress rule..."
  if ! $DRY_RUN; then
    EXISTING=$(aws ec2 describe-security-groups \
      --group-ids "$SG_ID" \
      --query "SecurityGroups[0].IpPermissions[?FromPort==\`3000\`] | length(@)" \
      --output text 2>/dev/null || echo "0")
    if [[ "$EXISTING" -gt 0 ]]; then
      warn "Port 3000 ingress rule already exists on ${SG_ID} — skipping."
    else
      info "Adding TCP/3000 ingress rule to ${SG_ID}..."
      aws ec2 authorize-security-group-ingress \
        --group-id "$SG_ID" \
        --protocol tcp \
        --port 3000 \
        --cidr 0.0.0.0/0
      success "Port 3000 opened on Security Group ${SG_ID}."
    fi
  else
    echo -e "  ${YELLOW}[DRY-RUN]${RESET} Would ensure TCP/3000 ingress on ${SG_ID}."
  fi
else
  warn "--sg-id not supplied. Skipping Security Group update."
  warn "Manually ensure port 3000 is open in the Indexer-EC2 security group"
  warn "to allow traffic from the Load Balancer / Cloudflare IP ranges."
fi

# Also check the host-level firewall on the node
remote "Check and open port 3000 in the OS firewall (iptables/ufw/firewalld)" "
set -euo pipefail

# UFW
if command -v ufw &>/dev/null; then
  if sudo ufw status | grep -q '3000.*ALLOW'; then
    echo 'ufw: port 3000 already allowed.'
  else
    sudo ufw allow 3000/tcp
    echo 'ufw: port 3000 allowed.'
  fi
# firewalld
elif command -v firewall-cmd &>/dev/null && sudo systemctl is-active --quiet firewalld; then
  if ! sudo firewall-cmd --query-port=3000/tcp --permanent; then
    sudo firewall-cmd --add-port=3000/tcp --permanent
    sudo firewall-cmd --reload
    echo 'firewalld: port 3000 opened.'
  else
    echo 'firewalld: port 3000 already open.'
  fi
else
  echo 'No managed firewall detected (ufw/firewalld). Skipping OS firewall step.'
  echo 'Ensure iptables / AWS Security Group rules allow TCP 3000 inbound.'
fi
"

success "Firewall check complete."

# =============================================================================
# STEP 5 — Pull latest code / images (if git repo present)
# =============================================================================
step "Step 5 — Pull latest code (if ${DEPLOY_DIR} is a git repo)"

remote "Optional git pull" "
set -euo pipefail
cd '${DEPLOY_DIR}'
if git rev-parse --is-inside-work-tree &>/dev/null; then
  echo 'Git repository detected — pulling latest changes...'
  git fetch --all --prune
  git pull --ff-only
  echo \"Now at commit: \$(git rev-parse --short HEAD)\"
else
  echo '${DEPLOY_DIR} is not a git repo — skipping pull.'
fi
"

# =============================================================================
# STEP 6 — docker compose up -d --build
# =============================================================================
step "Step 6 — Launch Docker Compose stack"

remote "docker compose up -d --build" "
set -euo pipefail
cd '${DEPLOY_DIR}'

# Detect compose file location
COMPOSE_FILE=\$(find . -maxdepth 2 \
  \\( -name 'docker-compose.yml' -o -name 'docker-compose.yaml' \
     -o -name 'compose.yml'      -o -name 'compose.yaml' \\) \
  -print -quit)
echo \"Using compose file: \$COMPOSE_FILE\"

# Load the env file if present
ENV_FLAG=\"\"
if [[ -f '${ENV_FILE}' ]]; then
  ENV_FLAG=\"--env-file '${ENV_FILE}'\"
fi

# Pull remote images first to minimise build time
docker compose -f \"\$COMPOSE_FILE\" \$ENV_FLAG pull --ignore-pull-failures 2>/dev/null || true

# Build and start
docker compose -f \"\$COMPOSE_FILE\" \$ENV_FLAG up -d --build --remove-orphans

echo ''
echo 'Services launched. Waiting 20 seconds for containers to stabilise...'
sleep 20
"

success "docker compose up completed."

# =============================================================================
# STEP 7 — Verification
# =============================================================================
step "Step 7 — Verify deployment"

remote "docker ps — confirm containers are Up/healthy" "
set -euo pipefail
echo '── Container Status ──────────────────────────────────────────────────'
docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' | \
  grep -E 'NAMES|explorer|indexer|postgres|redis|api' || \
  docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'

echo ''
echo '── Health Check: curl -I http://localhost:3000 ───────────────────────'
HTTP_STATUS=\$(curl -s -o /dev/null -w '%{http_code}' --max-time 10 http://localhost:3000 || echo 'FAILED')
echo \"HTTP response code: \$HTTP_STATUS\"

if [[ \"\$HTTP_STATUS\" =~ ^[23] ]]; then
  echo 'Frontend is responding — deployment successful.'
elif [[ \"\$HTTP_STATUS\" == 'FAILED' ]]; then
  echo 'WARNING: curl timed out. Container may still be starting (Next.js cold start).'
  echo 'Re-run the verification in 30 seconds:  curl -I http://localhost:3000'
  docker logs \$(docker ps -qf 'name=explorer') --tail 30 2>/dev/null || true
else
  echo \"WARNING: Unexpected HTTP status \$HTTP_STATUS\"
  docker logs \$(docker ps -qf 'name=explorer') --tail 30 2>/dev/null || true
fi

echo ''
echo '── Recent Explorer Logs ──────────────────────────────────────────────'
docker logs \$(docker ps -qf 'name=explorer') --tail 20 2>/dev/null || \
  echo '(explorer container not found — check docker ps above)'
"

# =============================================================================
# Done
# =============================================================================
step "Deployment Complete"
echo ""
echo -e "  ${GREEN}Explorer URL  :${RESET} ${NEXT_PUBLIC_SITE_URL}"
echo -e "  ${GREEN}Internal check:${RESET} curl -I http://${TARGET_IP}:3000"
echo -e "  ${GREEN}Logs          :${RESET} ssh -J ${BASTION_USER}@${BASTION_HOST} ${TARGET_USER}@${TARGET_IP} \\"
echo    "                    \"docker compose -f ${DEPLOY_DIR}/<compose-file> logs -f explorer\""
echo ""
echo -e "  ${YELLOW}Next steps if 522 persists:${RESET}"
echo    "  1. Confirm the Load Balancer target group health check points to :3000/."
echo    "  2. Confirm Cloudflare origin rule points to the Load Balancer DNS, not the EC2 IP directly."
echo    "  3. Verify the Sentry nodes (54.163.248.63, 52.41.98.79) accept connections"
echo    "     on :26657 and that the NLB endpoint is reachable on :8545."
echo ""
