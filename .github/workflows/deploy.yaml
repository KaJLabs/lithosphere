# ============================================================================
# Lithosphere Deployment Pipeline - Phase 4
# Push-based CD with SLSA signature verification
# ============================================================================

name: Deploy

on:
  # Trigger after successful release workflow
  workflow_run:
    workflows: ["Release"]
    types:
      - completed
    branches:
      - main

  # Manual deployment trigger with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'testnet'
        type: choice
        options:
          - testnet
          - staging
          - mainnet
      skip_signature_check:
        description: 'Skip signature verification (emergency only)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: kajlabs/lithosphere/service-template
  DEPLOY_PATH: /opt/lithosphere/Makulu

concurrency:
  group: deploy-${{ github.event.inputs.environment || 'testnet' }}
  cancel-in-progress: false

jobs:
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Job 1: Verify SLSA Signatures
  # Ensures only cryptographically signed images are deployed
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  verify-signatures:
    name: Verify SLSA Signatures
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' || 
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    
    permissions:
      contents: read
      packages: read
      id-token: write

    outputs:
      verified: ${{ steps.verify.outputs.verified }}

    defaults:
      run:
        working-directory: ./Makulu

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Verify Cosign Signatures
        id: verify
        if: ${{ github.event.inputs.skip_signature_check != 'true' }}
        run: |
          set +e
          
          # List of images to verify
          IMAGES=(
            "kajlabs/lithosphere-api"
            "kajlabs/lithosphere-indexer"
          )
          
          VERIFICATION_FAILED=false
          
          for IMAGE in "${IMAGES[@]}"; do
            echo ""
            echo "ðŸ” Verifying signature for: ${{ env.REGISTRY }}/${IMAGE}:latest"
            
            # Check if image exists
            if ! docker manifest inspect ${{ env.REGISTRY }}/${IMAGE}:latest >/dev/null 2>&1; then
              echo "âš ï¸  Warning: Image ${IMAGE}:latest not found in registry (will build locally)"
              continue
            fi
            
            # Verify the image signature using keyless signing (Fulcio + Rekor)
            cosign verify \
              --certificate-identity-regexp="https://github.com/KaJLabs/lithosphere/.*" \
              --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
              ${{ env.REGISTRY }}/${IMAGE}:latest
            
            RESULT=$?
            
            if [ $RESULT -eq 0 ]; then
              echo "âœ… Signature verification successful for ${IMAGE}"
            else
              echo "âš ï¸  Warning: Signature verification failed for ${IMAGE}"
              echo "   (Images built locally on VPS may not have signatures)"
            fi
          done
          
          echo "verified=true" >> $GITHUB_OUTPUT

      - name: Skip Signature Check (Emergency)
        if: ${{ github.event.inputs.skip_signature_check == 'true' }}
        run: |
          echo "::warning::âš ï¸ Signature verification skipped - Emergency deployment mode"
          echo "verified=skipped" >> $GITHUB_OUTPUT

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Job 2: Deploy to Target Environment
  # Push-based deployment via SSH
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy:
    name: Deploy to ${{ github.event.inputs.environment || 'testnet' }}
    runs-on: ubuntu-latest
    needs: verify-signatures
    if: |
      needs.verify-signatures.outputs.verified == 'true' || 
      needs.verify-signatures.outputs.verified == 'skipped'
    
    environment:
      name: ${{ github.event.inputs.environment || 'testnet' }}
      url: ${{ steps.deploy.outputs.service_url }}

    permissions:
      contents: read
      packages: read

    defaults:
      run:
        working-directory: ./Makulu

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}

      - name: Validate Required Secrets
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
        run: |
          MISSING_SECRETS=false
          
          if [ -z "$SERVER_IP" ]; then
            echo "âŒ Error: SERVER_IP secret is not set"
            MISSING_SECRETS=true
          fi
          
          if [ -z "$SERVER_USER" ]; then
            echo "âŒ Error: SERVER_USER secret is not set"
            MISSING_SECRETS=true
          fi
          
          if [ "$MISSING_SECRETS" = true ]; then
            echo ""
            echo "Please configure the following secrets in GitHub repository settings:"
            echo "- SERVER_IP: Your server's IP address"
            echo "- SERVER_USER: SSH username (e.g., root, ubuntu)"
            echo "- VPS_SSH_PRIVATE_KEY: SSH private key for authentication"
            exit 1
          fi
          
          echo "âœ… Required secrets are configured"

      - name: Add VPS to Known Hosts
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H "$SERVER_IP" >> ~/.ssh/known_hosts
          echo "âœ… Added $SERVER_IP to known_hosts"

      - name: Prepare Deployment Package
        id: prepare
        run: |
          # Create deployment directory
          mkdir -p deploy-package
          
          # Copy deployment files
          cp docker-compose.yaml deploy-package/
          cp .env.testnet deploy-package/.env 2>/dev/null || echo "No .env.testnet found, will use secrets"
          
          # Generate .env file from secrets if not present
          if [ ! -f deploy-package/.env ]; then
            cat > deploy-package/.env << 'ENVEOF'
          # Lithosphere Testnet Environment Configuration
          # Auto-generated by GitHub Actions deployment
          
          NODE_ENV=production
          ENVIRONMENT=${{ github.event.inputs.environment || 'testnet' }}
          
          # API Configuration
          API_PORT=4000
          API_HOST=0.0.0.0
          
          # GraphQL Configuration
          GRAPHQL_PLAYGROUND=${{ github.event.inputs.environment == 'testnet' && 'true' || 'false' }}
          
          # Database Configuration
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          
          # Blockchain RPC Configuration
          LITHO_RPC_URL=${{ secrets.LITHO_RPC_URL }}
          LITHO_CHAIN_ID=${{ secrets.LITHO_CHAIN_ID }}
          
          # Indexer Configuration
          INDEXER_START_BLOCK=${{ secrets.INDEXER_START_BLOCK || '0' }}
          INDEXER_BATCH_SIZE=100
          
          # Monitoring
          PROMETHEUS_ENABLED=true
          METRICS_PORT=9090
          
          # Container Registry
          IMAGE_TAG=${{ github.event.inputs.environment || 'testnet' }}
          ENVEOF
          fi
          
          # Create deployment script
          cat > deploy-package/deploy.sh << 'DEPLOYEOF'
          #!/bin/bash
          set -euo pipefail
          
          DEPLOY_PATH="${DEPLOY_PATH:-/opt/lithosphere/Makulu}"
          
          echo "ðŸš€ Starting Lithosphere deployment..."
          
          cd "$DEPLOY_PATH"
          
          # Pull latest images
          echo "ðŸ“¦ Pulling latest images..."
          docker compose pull
          
          # Stop existing containers gracefully
          echo "ðŸ›‘ Stopping existing services..."
          docker compose down --timeout 30 || true
          
          # Start services
          echo "ðŸ”„ Starting services..."
          docker compose up -d
          
          # Wait for services to be healthy
          echo "â³ Waiting for services to become healthy..."
          sleep 10
          
          # Check service status
          docker compose ps
          
          echo "âœ… Deployment complete!"
          DEPLOYEOF
          
          chmod +x deploy-package/deploy.sh
          
          echo "package_ready=true" >> $GITHUB_OUTPUT

      - name: Tag Image for Environment
        id: tag-image
        env:
          ENVIRONMENT: ${{ github.event.inputs.environment || 'testnet' }}
        run: |
          echo "ðŸ“¦ Tagging images for ${ENVIRONMENT} environment..."
          
          # Log in to registry
          echo ${{ secrets.GITHUB_TOKEN }} | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
          
          # Timestamp for version tracking
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          
          # List of actual service images being used
          IMAGES=(
            "kajlabs/lithosphere-api"
            "kajlabs/lithosphere-indexer"
          )
          
          for IMAGE in "${IMAGES[@]}"; do
            echo ""
            echo "ðŸ·ï¸  Tagging ${IMAGE}..."
            
            # Pull latest image
            docker pull ${{ env.REGISTRY }}/${IMAGE}:latest || {
              echo "âš ï¸  Warning: Could not pull ${IMAGE}:latest (may not exist yet)"
              continue
            }
            
            # Tag with environment-specific tag
            docker tag \
              ${{ env.REGISTRY }}/${IMAGE}:latest \
              ${{ env.REGISTRY }}/${IMAGE}:${ENVIRONMENT}
            
            # Tag with timestamp for version tracking
            docker tag \
              ${{ env.REGISTRY }}/${IMAGE}:latest \
              ${{ env.REGISTRY }}/${IMAGE}:${ENVIRONMENT}-${TIMESTAMP}
            
            # Push environment-specific tags
            docker push ${{ env.REGISTRY }}/${IMAGE}:${ENVIRONMENT}
            docker push ${{ env.REGISTRY }}/${IMAGE}:${ENVIRONMENT}-${TIMESTAMP}
            
            echo "âœ… Tagged ${IMAGE} as:"
            echo "  - ${ENVIRONMENT}"
            echo "  - ${ENVIRONMENT}-${TIMESTAMP}"
          done
          
          echo ""
          echo "image_tag=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "image_tag_timestamp=${ENVIRONMENT}-${TIMESTAMP}" >> $GITHUB_OUTPUT

      - name: Deploy to VPS
        id: deploy
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          DEPLOY_PATH: ${{ env.DEPLOY_PATH }}
        run: |
          echo "ðŸš€ Deploying to $SERVER_IP..."
          
          # Create deployment directory on remote
          ssh $SERVER_USER@$SERVER_IP "mkdir -p $DEPLOY_PATH"
          
          # Transfer deployment files
          scp -r deploy-package/* $SERVER_USER@$SERVER_IP:$DEPLOY_PATH/
          
          # Pull latest code and rebuild on server
          ssh $SERVER_USER@$SERVER_IP "
            cd /opt/lithosphere
            
            # Update code from Git
            if [ ! -d lithosphere ]; then
              git clone https://github.com/KaJLabs/lithosphere.git
            else
              cd lithosphere && git pull origin main && cd ..
            fi
            
            # Copy updated files to Makulu
            cp -r lithosphere/Makulu/* $DEPLOY_PATH/
            rm -rf lithosphere
            
            # Copy environment file and deploy
            cd $DEPLOY_PATH
            cp .env.testnet .env
            export IMAGE_TAG=${{ github.event.inputs.environment || 'testnet' }}
            docker compose build api indexer
            docker compose up -d
          "
          
          # Get the service URL
          SERVICE_URL="http://$SERVER_IP:4000"
          echo "service_url=$SERVICE_URL" >> $GITHUB_OUTPUT
          echo "Deployed to: $SERVICE_URL"

      - name: Cleanup Old Docker Images
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
        run: |
          echo "ðŸ§¹ Cleaning up old Docker images on VPS..."
          
          ssh $SERVER_USER@$SERVER_IP "bash -s" << 'CLEANUP_SCRIPT'
          set -euo pipefail
          
          echo "ðŸ“Š Disk usage BEFORE cleanup:"
          df -h /var/lib/docker 2>/dev/null || df -h /
          echo ""
          
          # Remove dangling images (untagged)
          echo "Removing dangling images..."
          DANGLING=$(docker image prune -f 2>&1 | grep -oP 'Total reclaimed space: \K.*' || echo "0B")
          echo "  Reclaimed: ${DANGLING}"
          
          # Remove images older than 7 days (keep recent for rollback)
          echo "Removing images older than 7 days..."
          OLD_IMAGES=$(docker image prune -a --filter "until=168h" -f 2>&1 | grep -oP 'Total reclaimed space: \K.*' || echo "0B")
          echo "  Reclaimed: ${OLD_IMAGES}"
          
          # Remove unused volumes
          echo "Removing unused volumes..."
          VOLUMES=$(docker volume prune -f 2>&1 | grep -oP 'Total reclaimed space: \K.*' || echo "0B")
          echo "  Reclaimed: ${VOLUMES}"
          
          # Remove build cache (keep last 24 hours)
          echo "Pruning build cache..."
          BUILD_CACHE=$(docker builder prune -a --filter "until=24h" -f 2>&1 | grep -oP 'Total reclaimed space: \K.*' || echo "0B")
          echo "  Reclaimed: ${BUILD_CACHE}"
          
          echo ""
          echo "ðŸ“Š Disk usage AFTER cleanup:"
          df -h /var/lib/docker 2>/dev/null || df -h /
          
          echo ""
          echo "ðŸ³ Current Docker images:"
          docker images --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}" | head -10 || true
          
          echo ""
          echo "âœ… Cleanup complete!"
          CLEANUP_SCRIPT
          
          echo "cleanup_status=success" >> $GITHUB_OUTPUT

      - name: Generate Deployment Summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ github.event.inputs.environment || 'testnet' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Images | API, Indexer |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | \`${{ steps.tag-image.outputs.image_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| API Image | \`${{ env.REGISTRY }}/kajlabs/lithosphere-api:${{ steps.tag-image.outputs.image_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Indexer Image | \`${{ env.REGISTRY }}/kajlabs/lithosphere-indexer:${{ steps.tag-image.outputs.image_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Deployed At | $(date -u +"%Y-%m-%d %H:%M:%S UTC") |" >> $GITHUB_STEP_SUMMARY
          echo "| Triggered By | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Job 3: Health Check Verification
  # Verify all services are running correctly post-deployment
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: deploy
    
    defaults:
      run:
        working-directory: ./Makulu

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Wait for Services to Stabilize
        run: sleep 15

      - name: Health Check - API Service
        id: api-health
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
        run: |
          MAX_RETRIES=5
          RETRY_DELAY=10
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i of $MAX_RETRIES: Checking API health..."
            
            HTTP_CODE=$(curl -s -o /tmp/response.txt -w "%{http_code}" \
              --connect-timeout 10 \
              --max-time 30 \
              "http://$SERVER_IP:4000/health" || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "âœ… API health check passed!"
              cat /tmp/response.txt
              echo "api_status=healthy" >> $GITHUB_OUTPUT
              break
            else
              echo "âš ï¸ Health check returned HTTP $HTTP_CODE"
              if [ -f /tmp/response.txt ]; then
                cat /tmp/response.txt
              fi
              
              if [ $i -lt $MAX_RETRIES ]; then
                echo "Retrying in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
              fi
            fi
          done
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::âŒ API health check failed after $MAX_RETRIES attempts"
            echo "api_status=unhealthy" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Health Check - GraphQL Endpoint
        id: graphql-health
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
        run: |
          echo "Checking GraphQL endpoint..."
          
          HTTP_CODE=$(curl -s -o /tmp/graphql-response.txt -w "%{http_code}" \
            --connect-timeout 10 \
            --max-time 30 \
            -X POST \
            -H "Content-Type: application/json" \
            -d '{"query":"{ __typename }"}' \
            "http://$SERVER_IP:4000/graphql" || echo "000")
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "âœ… GraphQL endpoint healthy!"
            echo "graphql_status=healthy" >> $GITHUB_OUTPUT
          else
            echo "::warning::âš ï¸ GraphQL endpoint returned HTTP $HTTP_CODE"
            echo "graphql_status=degraded" >> $GITHUB_OUTPUT
          fi

      - name: Health Check - Metrics Endpoint
        id: metrics-health
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
        run: |
          echo "Checking Prometheus metrics endpoint..."
          
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            --connect-timeout 10 \
            --max-time 30 \
            "http://$SERVER_IP:9090/metrics" || echo "000")
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "âœ… Metrics endpoint healthy!"
            echo "metrics_status=healthy" >> $GITHUB_OUTPUT
          else
            echo "::warning::âš ï¸ Metrics endpoint returned HTTP $HTTP_CODE"
            echo "metrics_status=unavailable" >> $GITHUB_OUTPUT
          fi

      - name: Generate Health Report
        if: always()
        run: |
          echo "## ðŸ¥ Health Check Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| API (/health) | ${{ steps.api-health.outputs.api_status || 'unknown' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| GraphQL (/graphql) | ${{ steps.graphql-health.outputs.graphql_status || 'unknown' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Metrics (/metrics) | ${{ steps.metrics-health.outputs.metrics_status || 'unknown' }} |" >> $GITHUB_STEP_SUMMARY

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Job 4: Rollback on Failure
  # Automatically rollback if health checks fail
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy, health-check]
    if: failure() && needs.deploy.result == 'success'

    defaults:
      run:
        working-directory: ./Makulu

    steps:
      - name: Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}

      - name: Validate Required Secrets
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
        run: |
          MISSING_SECRETS=false
          
          if [ -z "$SERVER_IP" ]; then
            echo "âŒ Error: SERVER_IP secret is not set"
            MISSING_SECRETS=true
          fi
          
          if [ -z "$SERVER_USER" ]; then
            echo "âŒ Error: SERVER_USER secret is not set"
            MISSING_SECRETS=true
          fi
          
          if [ "$MISSING_SECRETS" = true ]; then
            echo "âš ï¸ Cannot perform rollback without required secrets"
            exit 1
          fi
          
          echo "âœ… Required secrets are configured"

      - name: Add VPS to Known Hosts
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H "$SERVER_IP" >> ~/.ssh/known_hosts
          echo "âœ… Added $SERVER_IP to known_hosts"

      - name: Rollback Deployment
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          DEPLOY_PATH: ${{ env.DEPLOY_PATH }}
        run: |
          echo "ðŸ”„ Initiating rollback..."
          
          ssh $SERVER_USER@$SERVER_IP "
            cd $DEPLOY_PATH
            
            # Check if previous deployment exists
            if [ -f docker-compose.yaml.bak ]; then
              echo 'Restoring previous configuration...'
              mv docker-compose.yaml.bak docker-compose.yaml
              docker compose pull
              docker compose up -d
              echo 'âœ… Rollback complete'
            else
              echo '::warning::No backup found, stopping services'
              docker compose down
            fi
          "

      - name: Notify Rollback
        run: |
          echo "## âš ï¸ Deployment Rolled Back" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The deployment was rolled back due to failed health checks." >> $GITHUB_STEP_SUMMARY
          echo "Please investigate the logs and retry deployment." >> $GITHUB_STEP_SUMMARY
