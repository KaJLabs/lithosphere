# ============================================================================
# Lithosphere Simple Deployment Pipeline
# Git-based deployment to VPS
# ============================================================================

name: Deploy to VPS

on:
  # Trigger on push to main
  push:
    branches:
      - main
    paths:
      - 'Makulu/**'
      - '.github/workflows/deploy-simple.yaml'

  # Manual deployment trigger
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'testnet'
        type: choice
        options:
          - testnet
          - staging
          - mainnet

env:
  DEPLOY_PATH: /opt/lithosphere/Makulu
  LITHOSCAN_PATH: /opt/lithoscan
  EXPLORER_ENV_PATH: /opt/lithoscan/monitoring/explorer

concurrency:
  group: deploy-${{ github.event.inputs.environment || 'testnet' }}
  cancel-in-progress: false

jobs:
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest

    permissions:
      contents: read
      id-token: write   # Required for OIDC ‚Üí AWS role assumption (mainnet RDS)

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials (OIDC)
        if: github.event.inputs.environment == 'mainnet'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      - name: Fetch RDS Credentials from Secrets Manager
        if: github.event.inputs.environment == 'mainnet'
        id: rds-creds
        run: |
          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id "litho-mainnet-rds-credentials" \
            --query SecretString --output text)
          echo "::add-mask::$(echo "$SECRET_JSON" | jq -r '.password')"
          echo "rds_endpoint=$(echo "$SECRET_JSON" | jq -r '.host')" >> $GITHUB_OUTPUT
          echo "rds_username=$(echo "$SECRET_JSON" | jq -r '.username')" >> $GITHUB_OUTPUT
          echo "rds_password=$(echo "$SECRET_JSON" | jq -r '.password')" >> $GITHUB_OUTPUT

      - name: Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}

      - name: Validate Secrets
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
        run: |
          if [ -z "$SERVER_IP" ]; then
            echo "‚ùå Error: SERVER_IP secret is not set"
            exit 1
          fi
          if [ -z "$SERVER_USER" ]; then
            echo "‚ùå Error: SERVER_USER secret is not set"
            exit 1
          fi
          echo "‚úÖ Required secrets are configured"

      - name: Add Server to Known Hosts
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          ssh-keyscan -H ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts 2>&1 || echo "Warning: ssh-keyscan failed, will add on first connection"
          chmod 644 ~/.ssh/known_hosts || true

      - name: Deploy to Server
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          DEPLOY_PATH: ${{ env.DEPLOY_PATH }}
        run: |
          echo "üöÄ Deploying Lithosphere to $SERVER_IP..."
          
          # Update code on server
          ssh -o StrictHostKeyChecking=accept-new $SERVER_USER@$SERVER_IP << 'ENDSSH'
            set -e
            
            cd /opt/lithosphere
            
            echo "üì¶ Pulling latest code from GitHub..."
            if [ ! -d lithosphere ]; then
              git clone https://github.com/KaJLabs/lithosphere.git
            else
              cd lithosphere
              git fetch origin
              git reset --hard origin/main
              cd ..
            fi
            
            echo "üìã Copying files to deployment directory..."
            mkdir -p Makulu
            cp -r lithosphere/Makulu/* Makulu/
            cp -r lithosphere/.github Makulu/ 2>/dev/null || true
            
            echo "üîß Configuring environment..."
            cd Makulu
            ENV="${{ github.event.inputs.environment || 'testnet' }}"
            if [ -f ".env.${ENV}" ]; then
              cp ".env.${ENV}" .env
              echo "Using .env.${ENV}"
            elif [ ! -f .env ]; then
              cp .env.testnet .env
              echo "Fallback: using .env.testnet"
            fi

            echo "üê≥ Building Docker images..."
            docker compose build api indexer explorer
            
            echo "üîÑ Restarting services..."
            docker compose up -d
            
            echo "üßπ Cleaning up..."
            cd /opt/lithosphere
            rm -rf lithosphere
            
            echo "‚úÖ Deployment complete!"
          ENDSSH
          
          echo "Deployment finished at $(date)"

      - name: Inject RDS DATABASE_URL for Mainnet
        if: github.event.inputs.environment == 'mainnet'
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          RDS_ENDPOINT: ${{ steps.rds-creds.outputs.rds_endpoint }}
          RDS_USERNAME: ${{ steps.rds-creds.outputs.rds_username }}
          RDS_PASSWORD: ${{ steps.rds-creds.outputs.rds_password }}
        run: |
          if [ -n "$RDS_ENDPOINT" ] && [ -n "$RDS_PASSWORD" ]; then
            echo "üîí Injecting RDS DATABASE_URL into .env on remote..."
            ssh -o StrictHostKeyChecking=accept-new $SERVER_USER@$SERVER_IP << RDSSSH
              set -e
              cd /opt/lithosphere/Makulu
              sed -i "s|^DATABASE_URL=.*|DATABASE_URL=postgresql://${RDS_USERNAME}:${RDS_PASSWORD}@${RDS_ENDPOINT}:5432/lithoscan|" .env
              echo "DATABASE_URL set to RDS endpoint."
          RDSSSH
          else
            echo "::warning::RDS credentials not available ‚Äî skipping DATABASE_URL injection"
          fi

      # ‚îÄ‚îÄ Lithoscan Explorer deploy ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: Write Explorer Production .env
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          LITHOSCAN_PATH: ${{ env.LITHOSCAN_PATH }}
          EXPLORER_ENV_PATH: ${{ env.EXPLORER_ENV_PATH }}
        run: |
          echo "üìù Writing /opt/lithoscan/monitoring/explorer/.env on $SERVER_IP..."
          ssh -o StrictHostKeyChecking=accept-new $SERVER_USER@$SERVER_IP << 'ENVSSH'
            set -e
            sudo mkdir -p /opt/lithoscan/monitoring/explorer
            sudo tee /opt/lithoscan/monitoring/explorer/.env > /dev/null << 'ENVEOF'
# Lithosphere Explorer ‚Äî Production Environment
# Auto-generated by GitHub Actions deploy-simple.yaml
CHAIN_ID=lithosphere_777777-1
CHAIN_NAME=Lithosphere

# Endpoints ‚Äî Public domains (TLS via Nginx on Sentry 1)
RPC_URL=https://rpc.litho.ai
EVM_RPC_URL=http://litho-mainnet-rpc-nlb-90cbce98dabd2453.elb.us-east-1.amazonaws.com:8545
GRPC_URL=54.163.248.63:9090
RPC_ENDPOINTS=https://rpc.litho.ai,http://52.41.98.79:26657
GRPC_ENDPOINTS=54.163.248.63:9090,52.41.98.79:9090

# Indexer
START_BLOCK=1
BATCH_SIZE=100
LOG_LEVEL=info

# API
NODE_ENV=production
CORS_ORIGINS=https://makalu.litho.ai,https://status.litho.ai

# Frontend
NEXT_PUBLIC_SITE_URL=https://makalu.litho.ai
NEXT_PUBLIC_API_URL=https://makalu.litho.ai/api
NEXT_PUBLIC_RPC_URL=https://rpc.litho.ai
NEXT_PUBLIC_CHAIN_ID=lithosphere_777777-1
NEXT_PUBLIC_CHAIN_NAME=Lithosphere

# Network status
CHECK_INTERVAL=5000

# Database (passwords injected via GitHub Secrets on the host)
POSTGRES_DB=lithoscan
POSTGRES_USER=litho
ENVEOF
            sudo chmod 640 /opt/lithoscan/monitoring/explorer/.env
            echo "‚úÖ .env written:"
            cat /opt/lithoscan/monitoring/explorer/.env
          ENVSSH

      - name: Deploy Explorer Stack via docker compose
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          LITHOSCAN_PATH: ${{ env.LITHOSCAN_PATH }}
        run: |
          echo "üê≥ Deploying Explorer & Indexer stack at $LITHOSCAN_PATH..."
          ssh -o StrictHostKeyChecking=accept-new $SERVER_USER@$SERVER_IP << 'ENDSSH'
            set -e
            cd /opt/lithoscan

            # Locate the compose file under this directory
            COMPOSE_FILE=$(find . -maxdepth 2 \
              \( -name 'docker-compose.yml' -o -name 'docker-compose.yaml' \
                 -o -name 'compose.yml'      -o -name 'compose.yaml' \) \
              -print -quit)

            if [ -z "$COMPOSE_FILE" ]; then
              echo "‚ùå No docker-compose file found under /opt/lithoscan"
              ls -la /opt/lithoscan
              exit 1
            fi

            echo "Using compose file: $COMPOSE_FILE"

            # Pull remote images (best effort)
            docker compose -f "$COMPOSE_FILE" \
              --env-file /opt/lithoscan/monitoring/explorer/.env \
              pull --ignore-pull-failures 2>/dev/null || true

            # Build and launch
            docker compose -f "$COMPOSE_FILE" \
              --env-file /opt/lithoscan/monitoring/explorer/.env \
              up -d --build --remove-orphans

            echo "‚úÖ Explorer stack launched."
          ENDSSH

      # ‚îÄ‚îÄ Wait for all services ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: Wait for Services
        run: sleep 30

      - name: Health Check ‚Äî API Service
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
        run: |
          echo "üè• Running health checks..."

          MAX_RETRIES=5
          RETRY_DELAY=10

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i of $MAX_RETRIES: Checking API health..."

            HTTP_CODE=$(curl -s -o /tmp/response.txt -w "%{http_code}" \
              --connect-timeout 10 \
              --max-time 30 \
              "http://$SERVER_IP:4000/health" || echo "000")

            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ API health check passed!"
              cat /tmp/response.txt
              break
            else
              echo "‚ö†Ô∏è  Health check returned HTTP $HTTP_CODE"
              if [ -f /tmp/response.txt ]; then cat /tmp/response.txt; fi
              if [ $i -lt $MAX_RETRIES ]; then
                echo "Retrying in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
              fi
            fi
          done

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::‚ùå API health check failed after $MAX_RETRIES attempts"
            exit 1
          fi

      - name: Health Check ‚Äî Explorer Frontend (:3000)
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
        run: |
          echo "üåê Checking Explorer frontend at http://$SERVER_IP:3000 ..."

          MAX_RETRIES=6
          RETRY_DELAY=15

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i of $MAX_RETRIES..."
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
              --connect-timeout 10 --max-time 30 \
              "http://$SERVER_IP:3000" || echo "000")

            echo "  HTTP $HTTP_CODE"

            if [[ "$HTTP_CODE" =~ ^[23] ]]; then
              echo "‚úÖ Explorer is responding (HTTP $HTTP_CODE)"
              break
            fi

            if [ $i -lt $MAX_RETRIES ]; then
              echo "Next.js may still be compiling ‚Äî retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
            fi
          done

          if ! [[ "$HTTP_CODE" =~ ^[23] ]]; then
            echo "::error::‚ùå Explorer health check failed ‚Äî HTTP $HTTP_CODE"
            exit 1
          fi

      - name: Test API Endpoints
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
        run: |
          echo "üß™ Testing API endpoints..."
          
          # Test /health
          echo "Testing /health..."
          curl -f "http://$SERVER_IP:4000/health"
          
          # Test /api/litho
          echo -e "\n\nTesting /api/litho..."
          curl -f "http://$SERVER_IP:4000/api/litho"
          
          # Test GraphQL
          echo -e "\n\nTesting GraphQL..."
          curl -f -X POST \
            -H "Content-Type: application/json" \
            -d '{"query":"{ __typename }"}' \
            "http://$SERVER_IP:4000/graphql"
          
          echo -e "\n\n‚úÖ All endpoint tests passed!"

      - name: Generate Deployment Summary
        if: always()
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ github.event.inputs.environment || 'testnet' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Server IP | ${{ secrets.SERVER_IP }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Deployed At | $(date -u +"%Y-%m-%d %H:%M:%S UTC") |" >> $GITHUB_STEP_SUMMARY
          echo "| Triggered By | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Service URLs" >> $GITHUB_STEP_SUMMARY
          echo "- Explorer: https://makalu.litho.ai (internal: http://${{ secrets.SERVER_IP }}:3000)" >> $GITHUB_STEP_SUMMARY
          echo "- API: http://${{ secrets.SERVER_IP }}:4000" >> $GITHUB_STEP_SUMMARY
          echo "- GraphQL: http://${{ secrets.SERVER_IP }}:4000/graphql" >> $GITHUB_STEP_SUMMARY
          echo "- Health: http://${{ secrets.SERVER_IP }}:4000/health" >> $GITHUB_STEP_SUMMARY

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: deploy
    if: failure()

    steps:
      - name: Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}

      - name: Add Server to Known Hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts

      - name: Rollback
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          DEPLOY_PATH: ${{ env.DEPLOY_PATH }}
        run: |
          echo "‚ö†Ô∏è  Deployment failed, attempting rollback..."
          
          ssh $SERVER_USER@$SERVER_IP << 'ENDSSH'
            cd /opt/lithosphere/Makulu
            
            # Restart with previous version
            docker compose down --timeout 30
            docker compose up -d
            
            echo "Rollback initiated"
          ENDSSH
          
          echo "::warning::Deployment was rolled back due to health check failure"
